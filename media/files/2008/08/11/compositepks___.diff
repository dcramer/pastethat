Index: django/db/models/sql/where.py
===================================================================
--- django/db/models/sql/where.py	(revision 8295)
+++ django/db/models/sql/where.py	(working copy)
@@ -44,7 +44,7 @@
 
         alias, col, field, lookup_type, value = data
         try:
-            if field:
+            if isinstance(field, Field):
                 params = field.get_db_prep_lookup(lookup_type, value)
                 db_type = field.db_type()
             else:
Index: django/db/models/sql/query.py
===================================================================
--- django/db/models/sql/query.py	(revision 8295)
+++ django/db/models/sql/query.py	(working copy)
@@ -475,7 +475,6 @@
             table_alias = start_alias
         else:
             table_alias = self.tables[0]
-        root_pk = opts.pk.column
         seen = {None: table_alias}
         qn = self.quote_name_unless_alias
         qn2 = self.connection.ops.quote_name
@@ -485,7 +484,7 @@
                 alias = seen[model]
             except KeyError:
                 alias = self.join((table_alias, model._meta.db_table,
-                        root_pk, model._meta.pk.column))
+                   opts.pk.column, model._meta.pk.column))
                 seen[model] = alias
             if as_pairs:
                 result.append((alias, field.column))
Index: django/db/models/base.py
===================================================================
--- django/db/models/base.py	(revision 8295)
+++ django/db/models/base.py	(working copy)
@@ -260,12 +260,29 @@
     def _get_pk_val(self, meta=None):
         if not meta:
             meta = self._meta
-        return getattr(self, meta.pk.attname)
+        if len(meta.pks) == 1:
+            return getattr(self, meta.pk.attname)
+        return self._get_pk_vals()
+    
+    def _get_pk_vals(self, meta=None):
+        if not meta:
+            meta = self._meta
+        return [getattr(self, f.attname) for f in meta.pks]
 
-    def _set_pk_val(self, value):
-        return setattr(self, self._meta.pk.attname, value)
+    def _set_pk_val(self, values):
+        # Not quite sure why anyone would use a dictionary here,
+        # but it's supported to keep it in line with filter()
+        if isinstance(values, dict):
+            for key, val in value.iteritems():
+                setattr(self, key, val)
+        else:
+            if not hasattr(values, '__iter__') and len(self._meta.pks) == 1:
+                values = [values,]
+            for field_name, idx in izip(self._meta.pk.primary_key_attnames, xrange(len(self._meta.pks))):
+                setattr(self, field_name, values[idx])
 
     pk = property(_get_pk_val, _set_pk_val)
+    pks = property(_get_pk_vals, _set_pk_val)
 
     def save(self, force_insert=False, force_update=False):
         """
@@ -306,13 +323,19 @@
         # that might have come from the parent class - we just save the
         # attributes we have been given to the class we have been given.
         if not raw:
+            # TODO: GAHHHHHHH
             for parent, field in meta.parents.items():
                 # At this point, parent's primary key field may be unknown
                 # (for example, from administration form which doesn't fill
                 # this field). If so, fill it.
-                if getattr(self, parent._meta.pk.attname) is None and getattr(self, field.attname) is not None:
-                    setattr(self, parent._meta.pk.attname, getattr(self, field.attname))
 
+                # TODO: test that this is good enough
+                if getattr(self, parent._meta.pks[0].attname) is None and getattr(self, field.attname) is None:
+                # if getattr(self, parent._meta.pk.attname) is None and getattr(self, field.attname) is not None:
+                    for f in parent._meta.pks:
+                        setattr(self, f.attname, getattr(self, field.attname))
+                    # setattr(self, parent._meta.pk.attname, getattr(self, field.attname))
+
                 self.save_base(raw, parent)
                 setattr(self, field.attname, self._get_pk_val(parent._meta))
 
Index: django/db/models/options.py
===================================================================
--- django/db/models/options.py	(revision 8295)
+++ django/db/models/options.py	(working copy)
@@ -18,11 +18,51 @@
 # Calculate the verbose_name by converting from InitialCaps to "lowercase with spaces".
 get_verbose_name = lambda class_name: re.sub('(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))', ' \\1', class_name).lower().strip()
 
+# In case it needs changed.
+PRIMARY_KEY_STRING_SEPARATOR = '/'
+
 DEFAULT_NAMES = ('verbose_name', 'db_table', 'ordering',
                  'unique_together', 'permissions', 'get_latest_by',
                  'order_with_respect_to', 'app_label', 'db_tablespace',
                  'abstract')
 
+class CompositePrimaryKey(list):
+    def __eq__(self, field_name):
+        return field_name in self.primary_key_names
+    
+    def __repr__(self):
+        return '<%s: %s>' % (self.__class__.__name__, list.__repr__(self))
+
+    def __str__(self):
+        return self.name
+    
+    def __getattr__(self, key, value=None):
+        _reserved = ('primary_key_names', 'primary_key_attnames', 'append')
+        if key not in _reserved:
+            if len(self) == 1:
+                return getattr(self[0], key, value)
+            raise AttributeError, "'%s' is not accessible on '%s' objects" % (key, self.__class__.__name__,)
+        return list.__getattr__(self, key, value)
+    
+    def primary_key_names(self):
+        return [f.name for f in self]
+    primary_key_names = property(primary_key_names)
+
+    def primary_key_attnames(self):
+        return [f.attname for f in self]
+    primary_key_attnames = property(primary_key_attnames)
+
+    def append(self, field):
+        # Ensure the field is also marked with the primary_key attribute.
+        field.primary_key = True
+
+        if field not in self:
+            list.append(self, field)
+    
+    def name(self):
+        return '_'.join(self.primary_key_names)
+    name = property(name)
+
 class Options(object):
     def __init__(self, meta, app_label=None):
         self.local_fields, self.local_many_to_many = [], []
@@ -39,6 +79,7 @@
         self.admin = None
         self.meta = meta
         self.pk = None
+        self._primary_key = []
         self.has_auto_field, self.auto_field = False, None
         self.one_to_one_field = None
         self.abstract = False
@@ -55,10 +96,13 @@
         self.object_name = cls.__name__
         self.module_name = self.object_name.lower()
         self.verbose_name = get_verbose_name(self.object_name)
-
+        self.pk = CompositePrimaryKey()
+        
         # Next, apply any overridden values from 'class Meta'.
         if self.meta:
             meta_attrs = self.meta.__dict__.copy()
+            # We have to delay setup of this because self.fields isn't populated yet
+            self._primary_key = meta_attrs.pop('primary_key', [])
             for name in self.meta.__dict__:
                 # Ignore any private attributes that Django doesn't care about.
                 # NOTE: We can't modify a dictionary's contents while looping
@@ -95,7 +139,6 @@
             self.db_table = "%s_%s" % (self.app_label, self.module_name)
             self.db_table = truncate_name(self.db_table, connection.ops.max_name_length())
 
-
     def _prepare(self, model):
         if self.order_with_respect_to:
             self.order_with_respect_to = self.get_field(self.order_with_respect_to)
@@ -103,7 +146,13 @@
         else:
             self.order_with_respect_to = None
 
-        if self.pk is None:
+
+        # Now we initialize the primary key.
+        for field_name in self._primary_key:
+            self.pk.append(self.get_field(field_name))
+        del self._primary_key
+
+        if not self.pk:
             if self.parents:
                 # Promote the first parent link in lieu of adding yet another
                 # field.
@@ -153,10 +202,19 @@
             del self._name_map
 
     def setup_pk(self, field):
-        if not self.pk and field.primary_key:
-            self.pk = field
+        if field.primary_key and field not in self.pk:
+            self.pk.append(field)
             field.serialize = False
 
+    def pks(self):
+        return tuple(self.pk)
+        self.primary_key = lambda x: x.pk.primary_key_names
+    pks = property(pks)
+    
+    def primary_key(self):
+        return self.pk.primary_key_names
+    primary_key = property(primary_key)
+
     def __repr__(self):
         return '<Options for %s>' % self.object_name
 
Index: django/db/models/fields/__init__.py
===================================================================
--- django/db/models/fields/__init__.py	(revision 8295)
+++ django/db/models/fields/__init__.py	(working copy)
@@ -444,7 +444,7 @@
 class AutoField(Field):
     empty_strings_allowed = False
     def __init__(self, *args, **kwargs):
-        assert kwargs.get('primary_key', False) is True, "%ss must have primary_key=True." % self.__class__.__name__
+        # assert kwargs.get('primary_key', False) is True, "%ss must have primary_key=True." % self.__class__.__name__
         kwargs['blank'] = True
         Field.__init__(self, *args, **kwargs)
 
Index: django/db/models/__init__.py
===================================================================
--- django/db/models/__init__.py	(revision 8295)
+++ django/db/models/__init__.py	(working copy)
@@ -11,6 +11,7 @@
 from django.db.models.fields.files import FileField, ImageField
 from django.db.models.fields.related import ForeignKey, OneToOneField, ManyToManyField, ManyToOneRel, ManyToManyRel, OneToOneRel, TABULAR, STACKED
 from django.db.models import signals
+from django.db.models.options import PRIMARY_KEY_STRING_SEPARATOR
 
 # Admin stages.
 ADD, CHANGE, BOTH = 1, 2, 3
Index: django/core/serializers/xml_serializer.py
===================================================================
--- django/core/serializers/xml_serializer.py	(revision 8295)
+++ django/core/serializers/xml_serializer.py	(working copy)
@@ -83,7 +83,8 @@
         self._start_relational_field(field)
         related = getattr(obj, field.name)
         if related is not None:
-            if field.rel.field_name == related._meta.pk.name:
+            # TODO: can we remove the field_name part?
+            if field.rel.field_name in related._meta.pk.primary_key_names:
                 # Related to remote object via primary key
                 related = related._get_pk_val()
             else:
Index: django/core/serializers/python.py
===================================================================
--- django/core/serializers/python.py	(revision 8295)
+++ django/core/serializers/python.py	(working copy)
@@ -40,7 +40,8 @@
     def handle_fk_field(self, obj, field):
         related = getattr(obj, field.name)
         if related is not None:
-            if field.rel.field_name == related._meta.pk.name:
+            # TODO: can we remove the field_name part?
+            if field.rel.field_name in related._meta.pk.primary_key_names:
                 # Related to remote object via primary key
                 related = related._get_pk_val()
             else:
Index: django/core/management/validation.py
===================================================================
--- django/core/management/validation.py	(revision 8295)
+++ django/core/management/validation.py	(working copy)
@@ -23,6 +23,19 @@
     from django.db.models.loading import get_app_errors
     from django.db.models.fields.related import RelatedObject
 
+    def _check_field_tuple(opts, the_tuple, var_name):
+        """Verifies that all fields in opts.var_name are valid."""
+        for field_name in the_tuple:
+            try:
+                f = opts.get_field(field_name, many_to_many=True)
+            except models.FieldDoesNotExist:
+                e.add(opts, '"%s" refers to %s, a field that doesn\'t exist. Check your syntax.' % (var_name, field_name))
+            else:
+                if isinstance(f.rel, models.ManyToManyRel):
+                    e.add(opts, '"%s" refers to %s. ManyToManyFields are not supported in unique_together.' % (var_name, f.name))
+                if f not in opts.local_fields:
+                    e.add(opts, '"%s" refers to %s. This is not in the same model as the unique_together statement.' % (var_name, f.name))
+
     e = ModelErrorCollection(outfile)
 
     for (app_name, error) in get_app_errors().items():
@@ -33,7 +46,7 @@
 
         # Do field-specific validation.
         for f in opts.local_fields:
-            if f.name == 'id' and not f.primary_key and opts.pk.name == 'id':
+            if f.name == 'id' and not f.primary_key and 'id' not in [f.name for f in opts.pks]:
                 e.add(opts, '"%s": You can\'t use "id" as a field name, because each model automatically gets an "id" field if none of the fields have primary_key=True. You need to either remove/rename your "id" field or add primary_key=True to a field.' % f.name)
             if f.name.endswith('_'):
                 e.add(opts, '"%s": Field names cannot end with underscores, because this would lead to ambiguous queryset filters.' % f.name)
@@ -205,15 +218,9 @@
 
         # Check unique_together.
         for ut in opts.unique_together:
-            for field_name in ut:
-                try:
-                    f = opts.get_field(field_name, many_to_many=True)
-                except models.FieldDoesNotExist:
-                    e.add(opts, '"unique_together" refers to %s, a field that doesn\'t exist. Check your syntax.' % field_name)
-                else:
-                    if isinstance(f.rel, models.ManyToManyRel):
-                        e.add(opts, '"unique_together" refers to %s. ManyToManyFields are not supported in unique_together.' % f.name)
-                    if f not in opts.local_fields:
-                        e.add(opts, '"unique_together" refers to %s. This is not in the same model as the unique_together statement.' % f.name)
+            _check_field_tuple(opts, ut, 'unique_together')
 
+        # Check primary_key.
+        _check_field_tuple(opts, opts.primary_key, 'primary_key')
+
     return len(e.errors)
Index: django/core/management/sql.py
===================================================================
--- django/core/management/sql.py	(revision 8295)
+++ django/core/management/sql.py	(working copy)
@@ -268,9 +268,8 @@
         field_output = [style.SQL_FIELD(qn(f.column)),
             style.SQL_COLTYPE(col_type)]
         field_output.append(style.SQL_KEYWORD('%sNULL' % (not f.null and 'NOT ' or '')))
-        if f.primary_key:
-            field_output.append(style.SQL_KEYWORD('PRIMARY KEY'))
-        elif f.unique:
+        # Why do you have to check f.primary_key also?
+        if f.unique and not f.primary_key:
             field_output.append(style.SQL_KEYWORD('UNIQUE'))
         if tablespace and connection.features.supports_tablespaces and f.unique:
             # We must specify the index tablespace inline, because we
@@ -292,6 +291,9 @@
         table_output.append(style.SQL_FIELD(qn('_order')) + ' ' + \
             style.SQL_COLTYPE(models.IntegerField().db_type()) + ' ' + \
             style.SQL_KEYWORD('NULL'))
+    # Handle primary keys last to support multiples
+    table_output.append(style.SQL_KEYWORD('PRIMARY KEY') + ' (%s)' % \
+        ", ".join([style.SQL_FIELD(qn(f.column)) for f in opts.pks]))
     for field_constraints in opts.unique_together:
         table_output.append(style.SQL_KEYWORD('UNIQUE') + ' (%s)' % \
             ", ".join([style.SQL_FIELD(qn(opts.get_field(f).column)) for f in field_constraints]))
@@ -367,6 +369,7 @@
                 style.SQL_KEYWORD('NOT NULL PRIMARY KEY'),
                 tablespace_sql))
             if inline_references:
+                # TODO:
                 deferred = []
                 table_output.append('    %s %s %s %s (%s)%s,' %
                     (style.SQL_FIELD(qn(f.m2m_column_name())),
Index: django/contrib/admin/filterspecs.py
===================================================================
--- django/contrib/admin/filterspecs.py	(revision 8295)
+++ django/contrib/admin/filterspecs.py	(working copy)
@@ -58,8 +58,8 @@
             self.lookup_title = f.rel.to._meta.verbose_name
         else:
             self.lookup_title = f.verbose_name
-        self.lookup_kwarg = '%s__%s__exact' % (f.name, f.rel.to._meta.pk.name)
-        self.lookup_val = request.GET.get(self.lookup_kwarg, None)
+        self.lookup_kwarg = '%s__pk__exact' % (f.name,)
+        self.lookup_val = request.GET.get(self.lookup_kwarg, '').split(models.PRIMARY_KEY_URL_SEPARATOR)
         self.lookup_choices = f.rel.to._default_manager.all()
 
     def has_output(self):
@@ -73,7 +73,7 @@
                'query_string': cl.get_query_string({}, [self.lookup_kwarg]),
                'display': _('All')}
         for val in self.lookup_choices:
-            pk_val = getattr(val, self.field.rel.to._meta.pk.attname)
+            pk_val = models.PRIMARY_KEY_URL_SEPARATOR.join([getattr(val, f.attname) for f in self.field.rel.to._meta.pks])
             yield {'selected': self.lookup_val == smart_unicode(pk_val),
                    'query_string': cl.get_query_string({self.lookup_kwarg: pk_val}),
                    'display': val}
Index: django/contrib/databrowse/datastructures.py
===================================================================
--- django/contrib/databrowse/datastructures.py	(revision 8295)
+++ django/contrib/databrowse/datastructures.py	(working copy)
@@ -105,7 +105,7 @@
         return self.instance._get_pk_val()
 
     def url(self):
-        return mark_safe('%s%s/%s/objects/%s/' % (self.model.site.root_url, self.model.model._meta.app_label, self.model.model._meta.module_name, iri_to_uri(self.pk())))
+        return mark_safe('%s%s/%s/objects/%s/' % (self.model.site.root_url, self.model.model._meta.app_label, self.model.model._meta.module_name, models.PRIMARY_KEY_URL_SEPARATOR.join(iri_to_uri(self.pk()))))
 
     def fields(self):
         """
